package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"ApiTask/graph/model"
	"context"
	"fmt"
)

// CreateWallet is the resolver for the createWallet field.
func (r *mutationResolver) CreateWallet(ctx context.Context, input model.NewWallet) (*model.Wallet, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("database not set")
	}

	wallet := &model.Wallet{
		Address: input.Address,
		Balance: 1000000,
	}

	r.AddWalletDB(wallet)

	r.AddWalletMAP(wallet)

	return wallet, nil
}

// Transfer is the resolver for the transfer field.
func (r *mutationResolver) Transfer(ctx context.Context, fromAddress string, toAddress string, amount int32) (*model.TransferResult, error) {
	if r.DB == nil {
		return nil, fmt.Errorf("database not set")
	}

	if !r.CheckIfAddressExists(fromAddress) || !r.CheckIfAddressExists(toAddress) {
		return nil, fmt.Errorf("wallet not found")
	}

	if amount > 0 {
		r.threadsCountMutex.Lock()
		r.walletsLockedPositiveThreads[fromAddress]++
		r.threadsCountMutex.Unlock()
	}
	//r.walletsLockedPositiveThreads[toAddress]++

	flag := true

	for flag {
		r.walletsMutexes[fromAddress].Lock()
		r.threadsCountMutex.Lock()
		if r.walletsLockedPositiveThreads[fromAddress] > 0 && amount < 0 {
			r.walletsMutexes[fromAddress].Unlock()
		} else {
			flag = false
		}
		r.threadsCountMutex.Unlock()
	}

	if amount > 0 {
		r.threadsCountMutex.Lock()
		r.walletsLockedPositiveThreads[fromAddress]--
		r.threadsCountMutex.Unlock()
	}
	//r.walletsMutexes[fromAddress].Lock()
	r.walletsMutexes[toAddress].Lock()
	//defer r.walletsMutexes[fromAddress].Unlock()
	//defer r.walletsMutexes[toAddress].Unlock()

	fromBalance := r.wallets[fromAddress].Balance
	toBalance := r.wallets[toAddress].Balance

	if fromBalance-amount < 0 {
		r.walletsMutexes[fromAddress].Unlock()
		r.walletsMutexes[toAddress].Unlock()
		return nil, fmt.Errorf("insufficient balance")
	}
	fromBalance -= amount

	if toBalance+amount < 0 {
		r.walletsMutexes[fromAddress].Unlock()
		r.walletsMutexes[toAddress].Unlock()
		return nil, fmt.Errorf("insufficient balance")
	}
	toBalance += amount

	r.UpdateWalletBalanceDBandMAP(fromAddress, fromBalance)
	r.UpdateWalletBalanceDBandMAP(toAddress, toBalance)

	r.walletsMutexes[fromAddress].Unlock()
	r.walletsMutexes[toAddress].Unlock()

	return &model.TransferResult{
		FromAddress: fromAddress,
		ToAddress:   toAddress,
		Amount:      amount,
	}, nil
}

// Wallets is the resolver for the wallets field.
func (r *queryResolver) Wallets(ctx context.Context) ([]*model.Wallet, error) {
	var wallets []*model.Wallet

	r.namesListMutex.Lock()
	for i := 0; i < len(r.walletsNames); i++ {

		r.walletsMutexes[r.walletsNames[i]].Lock()
		wallets = append(wallets, r.wallets[r.walletsNames[i]])
		r.walletsMutexes[r.walletsNames[i]].Unlock()
	}
	r.namesListMutex.Unlock()

	return wallets, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
